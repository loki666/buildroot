From ab75953754bc74039ab5477908660c913b5f09fc Mon Sep 17 00:00:00 2001
From: Philippe Simons <simons.philippe@gmail.com>
Date: Thu, 9 Jan 2025 22:03:12 +0100
Subject: [PATCH] WIP: usb otg

---
 .../sun50i-h700-anbernic-rg35xx-2024.dts      | 32 ++++++++++++++++++-
 .../sun50i-h700-anbernic-rg35xx-h.dts         | 15 ++-------
 drivers/phy/allwinner/phy-sun4i-usb.c         | 18 +++++++++++
 3 files changed, 52 insertions(+), 13 deletions(-)

diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024.dts
index 9c522ee2c..44402e115 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-2024.dts
@@ -337,6 +337,25 @@ h616_vqmmc_regulator: mmc-regulator {
 		regulator-max-microvolt = <3300000>;
 		regulator-boot-on;
 	};
+
+	reg_vcc3v8_usb: regulator-vcc3v8-usb {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&pio 4 5 GPIO_ACTIVE_HIGH>; /* PE5 */
+		regulator-min-microvolt = <3800000>;
+		regulator-max-microvolt = <3800000>;
+		regulator-name = "vcc3v8-usb";
+	};
+
+	reg_usb0_vbus: regulator-usb0-vbus {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&pio 8 16 GPIO_ACTIVE_HIGH>; /* PI16 */
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-name = "usb0-vbus";
+		vin-supply = <&reg_vcc3v8_usb>;
+	};
 };
 
 &codec {
@@ -587,11 +606,22 @@ &uart0 {
 
 /* the AXP717 has USB type-C role switch functionality, not yet described by the binding */
 &usbotg {
-	dr_mode = "peripheral";   /* USB type-C receptable */
+	dr_mode = "otg";   /* USB type-C receptable */
+	status = "okay";
+};
+
+&ehci0 {
+	status = "okay";
+};
+
+&ohci0 {
 	status = "okay";
 };
 
 &usbphy {
+	usb0_id_det-gpios = <&pio 8 4 GPIO_ACTIVE_LOW>;
+	usb0_vbus_power-supply = <&usb_power>;
+	usb0_vbus-supply = <&reg_usb0_vbus>;
 	status = "okay";
 };
 
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h.dts b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h.dts
index 652e03ea8..ead1d4c8b 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h700-anbernic-rg35xx-h.dts
@@ -11,22 +11,13 @@ / {
 	compatible = "anbernic,rg35xx-h", "allwinner,sun50i-h700";
 	rocknix-dt-id = "sun50i-h700-anbernic-rg35xx-h";
 
-	reg_vcc3v8_usb: regulator-vcc3v8-usb {
-		compatible = "regulator-fixed";
-		enable-active-high;
-		gpio = <&pio 4 5 GPIO_ACTIVE_HIGH>; /* PE5 */
-		regulator-min-microvolt = <3800000>;
-		regulator-max-microvolt = <3800000>;
-		regulator-name = "vcc3v8-usb";
-	};
-
-	reg_vcc5v0_usb: regulator-vcc5v0-usb {
+	reg_usb1_vbus: regulator-usb1-vbus {
 		compatible = "regulator-fixed";
 		enable-active-high;
 		gpio = <&pio 8 7 GPIO_ACTIVE_HIGH>; /* PI7 */
 		regulator-min-microvolt = <5000000>;
 		regulator-max-microvolt = <5000000>;
-		regulator-name = "vcc5v0-usb";
+		regulator-name = "usb1-vbus";
 		vin-supply = <&reg_vcc3v8_usb>;
 	};
 };
@@ -44,5 +35,5 @@ &ohci1 {
 };
 
 &usbphy {
-	usb1_vbus-supply = <&reg_vcc5v0_usb>;
+	usb1_vbus-supply = <&reg_usb1_vbus>;
 };
diff --git a/drivers/phy/allwinner/phy-sun4i-usb.c b/drivers/phy/allwinner/phy-sun4i-usb.c
index b0f19e950..c0756bc64 100644
--- a/drivers/phy/allwinner/phy-sun4i-usb.c
+++ b/drivers/phy/allwinner/phy-sun4i-usb.c
@@ -404,13 +404,16 @@ static int sun4i_usb_phy0_get_id_det(struct sun4i_usb_phy_data *data)
 {
 	switch (data->dr_mode) {
 	case USB_DR_MODE_OTG:
+		printk(KERN_ERR "PSI sun4i_usb_phy0_get_id_det: data->dr_mode=USB_DR_MODE_OTG");
 		if (data->id_det_gpio)
 			return gpiod_get_value_cansleep(data->id_det_gpio);
 		else
 			return 1; /* Fallback to peripheral mode */
 	case USB_DR_MODE_HOST:
+		printk(KERN_ERR "PSI sun4i_usb_phy0_get_id_det: data->dr_mode=USB_DR_MODE_HOST");
 		return 0;
 	case USB_DR_MODE_PERIPHERAL:
+		printk(KERN_ERR "PSI sun4i_usb_phy0_get_id_det: data->dr_mode=USB_DR_MODE_PERIPHERAL");
 	default:
 		return 1;
 	}
@@ -421,16 +424,20 @@ static int sun4i_usb_phy0_get_vbus_det(struct sun4i_usb_phy_data *data)
 	if (data->vbus_det_gpio)
 		return gpiod_get_value_cansleep(data->vbus_det_gpio);
 
+	printk(KERN_ERR "PSI sun4i_usb_phy0_get_vbus_det: data->vbus_power_supply=%d", data->vbus_power_supply);
 	if (data->vbus_power_supply) {
 		union power_supply_propval val;
 		int r;
 
 		r = power_supply_get_property(data->vbus_power_supply,
 					      POWER_SUPPLY_PROP_PRESENT, &val);
+		printk(KERN_ERR "PSI sun4i_usb_phy0_get_vbus_det: r=%d, val.intval=%d", r, val.intval);
 		if (r == 0)
 			return val.intval;
 	}
 
+	printk(KERN_ERR "PSI sun4i_usb_phy0_get_vbus_det: Fallback");
+
 	/* Fallback: report vbus as high */
 	return 1;
 }
@@ -465,9 +472,12 @@ static int sun4i_usb_phy_power_on(struct phy *_phy)
 	struct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);
 	int ret;
 
+	printk(KERN_ERR "PSI sun4i_usb_phy_power_on");
+	printk(KERN_ERR "PSI sun4i_usb_phy_power_on: !phy->vbus=%d, phy->regulator_on=%d", !phy->vbus, phy->regulator_on);
 	if (!phy->vbus || phy->regulator_on)
 		return 0;
 
+	printk(KERN_ERR "PSI sun4i_usb_phy_power_on; data->vbus_det=%d", data->vbus_det);
 	/* For phy0 only turn on Vbus if we don't have an ext. Vbus */
 	if (phy->index == 0 && sun4i_usb_phy0_have_vbus_det(data) &&
 				data->vbus_det) {
@@ -480,6 +490,7 @@ static int sun4i_usb_phy_power_on(struct phy *_phy)
 		return ret;
 
 	phy->regulator_on = true;
+	printk(KERN_ERR "PSI sun4i_usb_phy_power_on: phy->regulator_on = true");
 
 	/* We must report Vbus high within OTG_TIME_A_WAIT_VRISE msec. */
 	if (phy->index == 0 && sun4i_usb_phy0_poll(data))
@@ -493,11 +504,13 @@ static int sun4i_usb_phy_power_off(struct phy *_phy)
 	struct sun4i_usb_phy *phy = phy_get_drvdata(_phy);
 	struct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);
 
+	printk(KERN_ERR "PSI sun4i_usb_phy_power_off");
 	if (!phy->vbus || !phy->regulator_on)
 		return 0;
 
 	regulator_disable(phy->vbus);
 	phy->regulator_on = false;
+	printk(KERN_ERR "PSI sun4i_usb_phy_power_off: phy->regulator_on = false");
 
 	/*
 	 * phy0 vbus typically slowly discharges, sometimes this causes the
@@ -516,6 +529,7 @@ static int sun4i_usb_phy_set_mode(struct phy *_phy,
 	struct sun4i_usb_phy_data *data = to_sun4i_usb_phy_data(phy);
 	int new_mode;
 
+	printk(KERN_ERR "PSI sun4i_usb_phy_set_mode: mode=%d", mode);
 	if (phy->index != 0) {
 		if (mode == PHY_MODE_USB_HOST)
 			return 0;
@@ -569,6 +583,7 @@ static void sun4i_usb_phy0_reroute(struct sun4i_usb_phy_data *data, int id_det)
 {
 	u32 regval;
 
+	printk(KERN_ERR "PSI sun4i_usb_phy0_reroute: id_det=%d", id_det);
 	regval = readl(data->base + REG_PHY_OTGCTL);
 	if (id_det == 0) {
 		/* Host mode. Route phy0 to EHCI/OHCI */
@@ -596,6 +611,9 @@ static void sun4i_usb_phy0_id_vbus_det_scan(struct work_struct *work)
 	id_det = sun4i_usb_phy0_get_id_det(data);
 	vbus_det = sun4i_usb_phy0_get_vbus_det(data);
 
+	printk(KERN_ERR "PSI sun4i_usb_phy0_id_vbus_det_scan: id_det=%d, vbus_det=%d", id_det, vbus_det);
+	printk(KERN_ERR "PSI sun4i_usb_phy0_id_vbus_det_scan: data->id_det=%d, data->vbus_det=%d", data->id_det, data->vbus_det);
+
 	mutex_lock(&phy0->mutex);
 
 	if (!data->phy0_init) {
-- 
2.47.1

